<html>

<head>
    <title>Sistemas Gráficos - 66.71</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">

    <link rel="stylesheet" href="styles.css">

    <script type="text/javascript" src="libs/gl-matrix.js"></script>
    <script type="text/javascript" src="libs/jquery-2.1.4.min.js"></script>
    <script type="text/javascript" src="libs/webgl-utils.js"></script>
    <script src="libs/dat.gui.min.js"></script>

    <script type="text/javascript" src="geometry.js"></script>
    <script type="text/javascript" src="camera.js"></script>
    <script type="text/javascript" src="land.js"></script>
    <script type="text/javascript" src="textured_geometry.js"></script>
    <script type="text/javascript" src="normal_textured_geometry.js"></script>
    <script type="text/javascript" src="n_map_geometry.js"></script>
    <script type="text/javascript" src="normal_reflect_geometry.js"></script>
    <script type="text/javascript" src="road_piece.js"></script>
    <script type="text/javascript" src="sidewalk.js"></script>
    <script type="text/javascript" src="street.js"></script>
    <script type="text/javascript" src="textured_sphere.js"></script>
    <script type="text/javascript" src="textured_cylinder.js"></script>
    <script type="text/javascript" src="colored_geometry.js"></script>
    <script type="text/javascript" src="colored_sphere.js"></script>
    <script type="text/javascript" src="colored_cylinder.js"></script>
    <script type="text/javascript" src="h_section.js"></script>
    <script type="text/javascript" src="h_transition.js"></script>
    <script type="text/javascript" src="h_cap.js"></script>
    <script type="text/javascript" src="curve.js"></script>
    <script type="text/javascript" src="bezier_curve.js"></script>
    <script type="text/javascript" src="bspline_base.js"></script>
    <script type="text/javascript" src="bspline.js"></script>
    <script type="text/javascript" src="wire.js"></script>
    <script type="text/javascript" src="gui.js"></script>
    <script type="text/javascript" src="orbital_camera.js"></script>
    <script type="text/javascript" src="fp_camera.js"></script>
    <script type="text/javascript" src="tensor_set.js"></script>
    <script type="text/javascript" src="support.js"></script>
    <script type="text/javascript" src="river.js"></script>
    <script type="text/javascript" src="land_portion.js"></script>
    <script type="text/javascript" src="crown.js"></script>
    <script type="text/javascript" src="pillar.js"></script>
    <script type="text/javascript" src="road.js"></script>
    <script type="text/javascript" src="tower.js"></script>
    <script type="text/javascript" src="bridge.js"></script>
    <script type="text/javascript" src="tree.js"></script>
    <script type="text/javascript" src="scene.js"></script>
    <script type="text/javascript" src="river_panel.js"></script>

    <script id="shader-fs-colored-obj" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vVertexColor;
        varying vec3 vLightWeighting;

        void main(void) {
            gl_FragColor = vec4(vVertexColor.rgb * vLightWeighting, 1.0);
        }
    </script>

    <script id="shader-vs-colored-obj" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec3 aVertexColor;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        uniform vec3 uAmbientColor;

        uniform vec3 uLightPosition;
        uniform vec3 uDirectionalColor;

        uniform bool uUseLighting;

        varying vec3 vVertexColor;
        varying vec3 vLightWeighting;

        void main(void) {
            vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            gl_Position = uPMatrix * pos_camera_view;

            vVertexColor = aVertexColor;

            vec3 light_dir =  normalize(uLightPosition - aVertexNormal);
            if (!uUseLighting) {
                vLightWeighting = vec3(1.0, 1.0, 1.0);
            } else {
                vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
                float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
                vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
            }
        }
    </script>

    <script id="shader-fs-textured-obj" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        uniform sampler2D uSampler;

        void main(void) {
            vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
            gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        }
    </script>

    <script id="shader-vs-textured-obj" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        uniform vec3 uLightPosition;

        uniform vec3 uAmbientIntensity;
        uniform vec3 uDiffuseIntensity;
        uniform vec3 uSpecularIntensity;

        uniform vec3 uAmbientReflectivity;
        uniform vec3 uDiffuseReflectivity;
        uniform vec3 uSpecularReflectivity;
        uniform float uShininess;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        void main(void) {
            vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            gl_Position = uPMatrix * pos_camera_view;

            vTextureCoord = aTextureCoord;

            vec3 light_dir =  normalize(uLightPosition - aVertexNormal);

            vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
            vec3 s = normalize(light_dir - vec3(pos_camera_view));
            vec3 v = normalize(-vec3(pos_camera_view));
            vec3 r = reflect(-s, transformedNormal);
            float sn = max(dot(s, transformedNormal), 0.0);

            vec3 ambient = uAmbientIntensity * uAmbientReflectivity;
            vec3 diffuse = uDiffuseReflectivity * uDiffuseIntensity * sn;
            vec3 specular = vec3(0.0);
            if (sn > 0.0){
                specular = uSpecularIntensity * uSpecularReflectivity * pow(max(dot(r,v), 0.0), uShininess);
            }

            vLightWeighting = ambient + diffuse + specular;
        }
    </script>

    <script id="shader-fs-normal-mapping" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 lightDir;
        varying vec2 vTextureCoord;
        varying vec3 viewDir;
        varying vec3 vVertexColor;

        uniform sampler2D NormalMapTex;

        uniform vec3 uAmbientIntensity;
        uniform vec3 uDiffuseIntensity;
        uniform vec3 uSpecularIntensity;

        uniform vec3 uAmbientReflectivity;
        uniform vec3 uDiffuseReflectivity;
        uniform vec3 uSpecularReflectivity;
        uniform float uShininess;

        vec3 phongModel(vec3 n) {
            vec3 r = reflect(-lightDir, n);
            vec3 ambient = uAmbientIntensity * uAmbientReflectivity;
            float sn = max(dot(lightDir, n), 0.0);
            vec3 diffuse = uDiffuseIntensity * uDiffuseReflectivity * sn;
            vec3 spec = vec3(0.0);
            if (sn > 0.0){
                spec = uSpecularIntensity * uSpecularReflectivity * pow(max(dot(r, viewDir), 0.0), uShininess);
            }
            return ambient + diffuse + spec;
        }

        void main() {
            vec4 normal = texture2D(NormalMapTex, vTextureCoord);

            gl_FragColor = vec4(vVertexColor.rgb * phongModel(normal.xyz), 1.0);
        }
    </script>

    <script id="shader-vs-normal-mapping" type="x-shader/x-vertex">
        varying vec3 lightDir;
        varying vec3 viewDir;
        varying vec2 vTextureCoord;
        varying vec3 vVertexColor;

        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;
        attribute vec4 aVertexTangent;
        attribute vec3 aVertexColor;

        uniform vec3 uLightPosition;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        void main(void){
            lightDir =  normalize(uLightPosition - aVertexNormal);

            vec3 n = normalize(uNMatrix * aVertexNormal);
            vec3 t = normalize(uNMatrix * vec3(aVertexTangent));

            vec3 b = normalize(cross(n, t)) * aVertexTangent.w;

            mat3 toObjectLocal = mat3(
                t.x, b.x, n.x,
                t.y, b.y, n.y,
                t.z, b.z, n.z
            );

            vec4 pos = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            lightDir = normalize(toObjectLocal*(uLightPosition.xyz-vec3(pos)));
            viewDir = toObjectLocal*vec3(normalize(-pos));

            vTextureCoord = aTextureCoord;
            vVertexColor = aVertexColor;

            gl_Position = uPMatrix * pos;
        }
    </script>

    <script id="shader-fs-normal-and-reflect" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 lightDir;
        varying vec2 vTextureCoord;
        varying vec3 viewDir;
        varying vec3 vVertexColor;

        varying vec3 vReflectDir;

        uniform sampler2D NormalMapTex;
        uniform samplerCube uCubeMap;

        uniform float uAlpha;

        uniform vec3 uAmbientIntensity;
        uniform vec3 uDiffuseIntensity;
        uniform vec3 uSpecularIntensity;

        uniform vec3 uAmbientReflectivity;
        uniform vec3 uDiffuseReflectivity;
        uniform vec3 uSpecularReflectivity;
        uniform float uShininess;

        uniform float uReflectFactor;

        vec3 phongModel(vec3 n) {
            vec3 r = reflect(-lightDir, n);
            vec3 ambient = uAmbientIntensity * uAmbientReflectivity;
            float sn = max(dot(lightDir, n), 0.0);
            vec3 diffuse = uDiffuseIntensity * uDiffuseReflectivity * sn;
            vec3 spec = vec3(0.0);
            if (sn > 0.0){
                spec = uSpecularIntensity * uSpecularReflectivity * pow(max(dot(r, viewDir), 0.0), uShininess);
            }
            return ambient + diffuse + spec;
        }

        void main() {
            vec4 normal = texture2D(NormalMapTex, vTextureCoord);
            vec4 normalMapping = vec4(vVertexColor.rgb * phongModel(normal.xyz), 1.0);

            vec4 cubeMapColor = textureCube(uCubeMap, vReflectDir);

            gl_FragColor = mix(normalMapping, cubeMapColor, uReflectFactor);
            gl_FragColor[3] = gl_FragColor[3]*uAlpha;
        }
    </script>

    <script id="shader-vs-normal-and-reflect" type="x-shader/x-vertex">
        varying vec3 lightDir;
        varying vec3 viewDir;
        varying vec2 vTextureCoord;
        varying vec3 vVertexColor;

        varying vec3 vReflectDir;

        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;
        attribute vec4 aVertexTangent;
        attribute vec3 aVertexColor;

        uniform vec3 uLightPosition;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        uniform vec3 uWorldCameraPosition;

        void main(void){
            lightDir =  normalize(uLightPosition - aVertexNormal);

            vec3 n = normalize(uNMatrix * aVertexNormal);
            vec3 t = normalize(uNMatrix * vec3(aVertexTangent));

            vec3 b = normalize(cross(n, t)) * aVertexTangent.w;

            mat3 toObjectLocal = mat3(
                t.x, b.x, n.x,
                t.y, b.y, n.y,
                t.z, b.z, n.z
            );

            vec4 pos = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            lightDir = normalize(toObjectLocal*(uLightPosition.xyz-vec3(pos)));
            viewDir = toObjectLocal*vec3(normalize(-pos));

            vTextureCoord = aTextureCoord;
            vVertexColor = aVertexColor;

            vec3 worldPos = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));
            vec3 worldNorm = vec3(uModelMatrix * vec4(aVertexNormal, 0.0));
            vec3 worldView = normalize(uWorldCameraPosition - worldPos);
            vReflectDir = reflect(-worldView, worldNorm);

            gl_Position = uPMatrix * pos;
        }
    </script>

    <script id="shader-fs-normal-textured" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 lightDir;
        varying vec2 vTextureCoord;
        varying vec3 viewDir;
        varying vec3 vVertexColor;

        uniform sampler2D NormalMapTex;
        uniform sampler2D uTexture;

        uniform vec3 uAmbientIntensity;
        uniform vec3 uDiffuseIntensity;
        uniform vec3 uSpecularIntensity;

        uniform vec3 uAmbientReflectivity;
        uniform vec3 uDiffuseReflectivity;
        uniform vec3 uSpecularReflectivity;
        uniform float uShininess;

        vec3 phongModel(vec3 n) {
            vec3 r = reflect(-lightDir, n);
            vec3 ambient = uAmbientIntensity * uAmbientReflectivity;
            float sn = max(dot(lightDir, n), 0.0);
            vec3 diffuse = uDiffuseIntensity * uDiffuseReflectivity * sn;
            vec3 spec = vec3(0.0);
            if (sn > 0.0){
                spec = uSpecularIntensity * uSpecularReflectivity * pow(max(dot(r, viewDir), 0.0), uShininess);
            }
            return ambient + diffuse + spec;
        }

        void main() {
            vec4 textureColor = texture2D(uTexture, vec2(vTextureCoord.s, vTextureCoord.t));
            vec4 normal = texture2D(NormalMapTex, vTextureCoord);

            gl_FragColor = vec4(textureColor.rgb * phongModel(normal.xyz), 1.0);
        }
    </script>

    <script id="shader-vs-normal-textured" type="x-shader/x-vertex">
        varying vec3 lightDir;
        varying vec3 viewDir;
        varying vec2 vTextureCoord;

        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;
        attribute vec4 aVertexTangent;
        attribute vec3 aVertexColor;

        uniform vec3 uLightPosition;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        void main(void){
            lightDir =  normalize(uLightPosition - aVertexNormal);

            vec3 n = normalize(uNMatrix * aVertexNormal);
            vec3 t = normalize(uNMatrix * vec3(aVertexTangent));

            vec3 b = normalize(cross(n, t)) * aVertexTangent.w;

            mat3 toObjectLocal = mat3(
                t.x, b.x, n.x,
                t.y, b.y, n.y,
                t.z, b.z, n.z
            );

            vec4 pos = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            lightDir = normalize(toObjectLocal*(uLightPosition.xyz-vec3(pos)));
            viewDir = toObjectLocal*vec3(normalize(-pos));

            vTextureCoord = aTextureCoord;

            gl_Position = uPMatrix * pos;
        }
    </script>

    <script id="shader-fs-terrain" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 lightDir;
        varying vec2 vTextureCoord;
        varying vec3 viewDir;
        varying vec3 vVertexColor;

        varying float vIsLand;
        varying float vIsRock;

        uniform sampler2D uEarthColors;
        uniform sampler2D uRockColors;
        uniform sampler2D uSandColors;
        uniform sampler2D uEarthNormals;
        uniform sampler2D uRockNormals;
        uniform sampler2D uSandNormals;

        uniform vec3 uAmbientIntensity;
        uniform vec3 uDiffuseIntensity;
        uniform vec3 uSpecularIntensity;

        uniform vec3 uAmbientReflectivity;
        uniform vec3 uDiffuseReflectivity;
        uniform vec3 uSpecularReflectivity;
        uniform float uShininess;

        vec3 phongModel(vec3 n) {
            vec3 r = reflect(-lightDir, n);
            vec3 ambient = uAmbientIntensity * uAmbientReflectivity;
            float sn = max(dot(lightDir, n), 0.0);
            vec3 diffuse = uDiffuseIntensity * uDiffuseReflectivity * sn;
            vec3 spec = vec3(0.0);
            if (sn > 0.0){
                spec = uSpecularIntensity * uSpecularReflectivity * pow(max(dot(r, viewDir), 0.0), uShininess);
            }
            return ambient + diffuse + spec;
        }

        vec4 mix_component(sampler2D colors, sampler2D normals){
            vec4 color = texture2D(colors, vec2(vTextureCoord.s, vTextureCoord.t));
            vec4 normal = texture2D(normals, vTextureCoord);
            return vec4(color.rgb * phongModel(normal.xyz), 1.0);
        }

        void main() {
            if (vIsLand == 1.0) gl_FragColor = mix_component(uEarthColors, uEarthNormals);
            else if (vIsRock == 0.0) gl_FragColor = mix_component(uSandColors, uSandNormals);
            else gl_FragColor = gl_FragColor = mix_component(uRockColors, uRockNormals);
        }
    </script>

    <script id="shader-vs-terrain" type="x-shader/x-vertex">
        varying vec3 lightDir;
        varying vec3 viewDir;
        varying vec2 vTextureCoord;

        varying float vIsLand;
        varying float vIsRock;

        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;
        attribute vec4 aVertexTangent;
        attribute vec3 aVertexColor;
        attribute float aIsLand;
        attribute float aIsRock;

        uniform vec3 uLightPosition;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        void main(void){
            lightDir =  normalize(uLightPosition - aVertexNormal);

            vec3 n = normalize(uNMatrix * aVertexNormal);
            vec3 t = normalize(uNMatrix * vec3(aVertexTangent));

            vec3 b = normalize(cross(n, t)) * aVertexTangent.w;

            mat3 toObjectLocal = mat3(
                t.x, b.x, n.x,
                t.y, b.y, n.y,
                t.z, b.z, n.z
            );

            vec4 pos = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            lightDir = normalize(toObjectLocal*(uLightPosition.xyz-vec3(pos)));
            viewDir = toObjectLocal*vec3(normalize(-pos));

            vTextureCoord = aTextureCoord;

            vIsLand = aIsLand;
            vIsRock = aIsRock;

            gl_Position = uPMatrix * pos;
        }
    </script>

    <script type="text/javascript">
        function onMouseClick(){
            mouseDown = true;
        }
        function onMouseRelease(){
            mouseDown = false;
            lastMouseX = null;
            lastMouseY = null;
        }
    </script>

    <script type="text/javascript">
        var gl;

        var textures = {
            land: {
                earth: {
                    color: "maps/grass3.jpg",
                    normal: "maps/grass_normalmap.jpg"
                },
                rock: {
                    color: "maps/rock2.jpg",
                    normal: "maps/rock_normalmap.jpg"
                },
                sand: {
                    color: "maps/sand.jpg",
                    normal: "maps/sand_normalmap.jpg"
                }
            },
            rust: {
                color: "maps/rust.jpg",
                normal: "maps/rust_normalmap.jpg"
            },
            wire: "maps/wires_normalmap.jpg",
            sky: "maps/sky_lightblue_mod.jpg",
            crown: "maps/leaves.jpg",
            bark: "maps/bark.jpg",
            road: {
                sidewalk: {
                    color: "maps/sidewalk.jpg",
                    normal: "maps/concrete_normalmap.jpg"
                },
                street: {
                    color: "maps/asphalt.jpg",
                    normal: "maps/concrete_normalmap.jpg"
                }
            },
            water_normal: "maps/water_normal3.jpg",
            skybox: {
                top: "maps/cubemapsky_top.jpg",
                back: "maps/cubemapsky_back.jpg",
                bottom: "maps/cubemapsky_bottom.jpg",
                front: "maps/cubemapsky_front.jpg",
                left: "maps/cubemapsky_left.jpg",
                right: "maps/cubemapsky_right.jpg"
            }
        };

        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {}
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function getShader(gl, id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }

            var str = "";
            var k = shaderScript.firstChild;
            while (k) {
                if (k.nodeType == 3) {
                    str += k.textContent;
                }
                k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, str);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        var shaderProgramTexturedObject;
        var shaderProgramColoredObject;
        var shaderProgramNMapObject;
        var shaderProgramNormalTexturedObject;
        var shaderProgramNormalReflectObject;
        var shaderProgramTerrain;

        function initShaders() {
            initTexturedShader();
            initColoredShader();
            initNormalMapShader();
            initNormalTexturedShader();
            initNormalReflectShader();
            initTerrainShader();
        }

        function initTexturedShader(){
            //Setup
            var fragmentShaderTexturedObj = getShader(gl, "shader-fs-textured-obj");
            var vertexShaderTexturedObj = getShader(gl, "shader-vs-textured-obj");
            shaderProgramTexturedObject = gl.createProgram();
            gl.attachShader(shaderProgramTexturedObject, vertexShaderTexturedObj);
            gl.attachShader(shaderProgramTexturedObject, fragmentShaderTexturedObj);
            gl.linkProgram(shaderProgramTexturedObject);
            if (!gl.getProgramParameter(shaderProgramTexturedObject, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            //Buffers & matrices
            shaderProgramTexturedObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramTexturedObject.vertexPositionAttribute);
            shaderProgramTexturedObject.textureCoordAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramTexturedObject.textureCoordAttribute);
            shaderProgramTexturedObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramTexturedObject.vertexNormalAttribute);
            shaderProgramTexturedObject.pMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uPMatrix");
            shaderProgramTexturedObject.ViewMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uViewMatrix");
            shaderProgramTexturedObject.ModelMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uModelMatrix");
            shaderProgramTexturedObject.nMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uNMatrix");

            //Texture
            shaderProgramTexturedObject.samplerUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uSampler");

            //Light specs
            shaderProgramTexturedObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uLightPosition");
            shaderProgramTexturedObject.ambientIntensityUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uAmbientIntensity");
            shaderProgramTexturedObject.diffuseIntensityUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uDiffuseIntensity");
            shaderProgramTexturedObject.specularIntensityUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uSpecularIntensity");

            //Material specs
            shaderProgramTexturedObject.ambientReflectivityUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uAmbientReflectivity");
            shaderProgramTexturedObject.diffuseReflectivityUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uDiffuseReflectivity");
            shaderProgramTexturedObject.specularReflectivityUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uSpecularReflectivity");
            shaderProgramTexturedObject.shininessUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uShininess");
        }

        function initNormalMapShader(){
            //Setup
            var fragmentShaderNMapObj = getShader(gl, "shader-fs-normal-mapping");
            var vertexShaderNMapObj = getShader(gl, "shader-vs-normal-mapping");
            shaderProgramNMapObject = gl.createProgram();
            gl.attachShader(shaderProgramNMapObject, vertexShaderNMapObj);
            gl.attachShader(shaderProgramNMapObject, fragmentShaderNMapObj);
            gl.linkProgram(shaderProgramNMapObject);
            if (!gl.getProgramParameter(shaderProgramNMapObject, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            //Buffers & matrices
            shaderProgramNMapObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramNMapObject, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramNMapObject.vertexPositionAttribute);
            shaderProgramNMapObject.textureCoordAttribute = gl.getAttribLocation(shaderProgramNMapObject, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramNMapObject.textureCoordAttribute);
            shaderProgramNMapObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramNMapObject, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramNMapObject.vertexNormalAttribute);
            shaderProgramNMapObject.vertexTangentAttribute = gl.getAttribLocation(shaderProgramNMapObject, "aVertexTangent");
            gl.enableVertexAttribArray(shaderProgramNMapObject.vertexTangentAttribute);
            shaderProgramNMapObject.vertexColorAttribute = gl.getAttribLocation(shaderProgramNMapObject, "aVertexColor");
            gl.enableVertexAttribArray(shaderProgramNMapObject.vertexColorAttribute);
            shaderProgramNMapObject.pMatrixUniform = gl.getUniformLocation(shaderProgramNMapObject, "uPMatrix");
            shaderProgramNMapObject.ViewMatrixUniform = gl.getUniformLocation(shaderProgramNMapObject, "uViewMatrix");
            shaderProgramNMapObject.ModelMatrixUniform = gl.getUniformLocation(shaderProgramNMapObject, "uModelMatrix");
            shaderProgramNMapObject.nMatrixUniform = gl.getUniformLocation(shaderProgramNMapObject, "uNMatrix");

            //Texture
            shaderProgramNMapObject.normalMapUniform = gl.getUniformLocation(shaderProgramNMapObject, "NormalMapTex");

            //Light specs
            shaderProgramNMapObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramNMapObject, "uLightPosition");
            shaderProgramNMapObject.ambientIntensityUniform = gl.getUniformLocation(shaderProgramNMapObject, "uAmbientIntensity");
            shaderProgramNMapObject.diffuseIntensityUniform = gl.getUniformLocation(shaderProgramNMapObject, "uDiffuseIntensity");
            shaderProgramNMapObject.specularIntensityUniform = gl.getUniformLocation(shaderProgramNMapObject, "uSpecularIntensity");

            //Material specs
            shaderProgramNMapObject.ambientReflectivityUniform = gl.getUniformLocation(shaderProgramNMapObject, "uAmbientReflectivity");
            shaderProgramNMapObject.diffuseReflectivityUniform = gl.getUniformLocation(shaderProgramNMapObject, "uDiffuseReflectivity");
            shaderProgramNMapObject.specularReflectivityUniform = gl.getUniformLocation(shaderProgramNMapObject, "uSpecularReflectivity");
            shaderProgramNMapObject.shininessUniform = gl.getUniformLocation(shaderProgramNMapObject, "uShininess");
        }

        function initNormalTexturedShader(){
            //Setup
            var fragmentShaderNTObj = getShader(gl, "shader-fs-normal-textured");
            var vertexShaderNTObj = getShader(gl, "shader-vs-normal-textured");
            shaderProgramNormalTexturedObject = gl.createProgram();
            gl.attachShader(shaderProgramNormalTexturedObject, vertexShaderNTObj);
            gl.attachShader(shaderProgramNormalTexturedObject, fragmentShaderNTObj);
            gl.linkProgram(shaderProgramNormalTexturedObject);
            if (!gl.getProgramParameter(shaderProgramNormalTexturedObject, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            //Buffers & matrices
            shaderProgramNormalTexturedObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramNormalTexturedObject, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramNormalTexturedObject.vertexPositionAttribute);
            shaderProgramNormalTexturedObject.textureCoordAttribute = gl.getAttribLocation(shaderProgramNormalTexturedObject, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramNormalTexturedObject.textureCoordAttribute);
            shaderProgramNormalTexturedObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramNormalTexturedObject, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramNormalTexturedObject.vertexNormalAttribute);
            shaderProgramNormalTexturedObject.vertexTangentAttribute = gl.getAttribLocation(shaderProgramNormalTexturedObject, "aVertexTangent");
            gl.enableVertexAttribArray(shaderProgramNormalTexturedObject.vertexTangentAttribute);
            shaderProgramNormalTexturedObject.pMatrixUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uPMatrix");
            shaderProgramNormalTexturedObject.ViewMatrixUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uViewMatrix");
            shaderProgramNormalTexturedObject.ModelMatrixUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uModelMatrix");
            shaderProgramNormalTexturedObject.nMatrixUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uNMatrix");

            //Texture
            shaderProgramNormalTexturedObject.normalMapUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "NormalMapTex");
            shaderProgramNormalTexturedObject.textureUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uTexture");

            //Light specs
            shaderProgramNormalTexturedObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uLightPosition");
            shaderProgramNormalTexturedObject.ambientIntensityUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uAmbientIntensity");
            shaderProgramNormalTexturedObject.diffuseIntensityUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uDiffuseIntensity");
            shaderProgramNormalTexturedObject.specularIntensityUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uSpecularIntensity");

            //Material specs
            shaderProgramNormalTexturedObject.ambientReflectivityUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uAmbientReflectivity");
            shaderProgramNormalTexturedObject.diffuseReflectivityUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uDiffuseReflectivity");
            shaderProgramNormalTexturedObject.specularReflectivityUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uSpecularReflectivity");
            shaderProgramNormalTexturedObject.shininessUniform = gl.getUniformLocation(shaderProgramNormalTexturedObject, "uShininess");
        }

        function initTerrainShader(){
            //Setup
            var fragmentShaderTerrain = getShader(gl, "shader-fs-terrain");
            var vertexShaderTerrain = getShader(gl, "shader-vs-terrain");
            shaderProgramTerrain = gl.createProgram();
            gl.attachShader(shaderProgramTerrain, vertexShaderTerrain);
            gl.attachShader(shaderProgramTerrain, fragmentShaderTerrain);
            gl.linkProgram(shaderProgramTerrain);
            if (!gl.getProgramParameter(shaderProgramTerrain, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            //Buffers
            shaderProgramTerrain.vertexPositionAttribute = gl.getAttribLocation(shaderProgramTerrain, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramTerrain.vertexPositionAttribute);
            shaderProgramTerrain.textureCoordAttribute = gl.getAttribLocation(shaderProgramTerrain, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramTerrain.textureCoordAttribute);
            shaderProgramTerrain.vertexNormalAttribute = gl.getAttribLocation(shaderProgramTerrain, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramTerrain.vertexNormalAttribute);
            shaderProgramTerrain.vertexTangentAttribute = gl.getAttribLocation(shaderProgramTerrain, "aVertexTangent");
            gl.enableVertexAttribArray(shaderProgramTerrain.vertexTangentAttribute);

            shaderProgramTerrain.vertexIsLandAttribute = gl.getAttribLocation(shaderProgramTerrain, "aIsLand");
            gl.enableVertexAttribArray(shaderProgramTerrain.vertexIsLandAttribute);
            shaderProgramTerrain.vertexIsRockAttribute = gl.getAttribLocation(shaderProgramTerrain, "aIsRock");
            gl.enableVertexAttribArray(shaderProgramTerrain.vertexIsRockAttribute);

            //Matrices
            shaderProgramTerrain.pMatrixUniform = gl.getUniformLocation(shaderProgramTerrain, "uPMatrix");
            shaderProgramTerrain.ViewMatrixUniform = gl.getUniformLocation(shaderProgramTerrain, "uViewMatrix");
            shaderProgramTerrain.ModelMatrixUniform = gl.getUniformLocation(shaderProgramTerrain, "uModelMatrix");
            shaderProgramTerrain.nMatrixUniform = gl.getUniformLocation(shaderProgramTerrain, "uNMatrix");

            //Texture
            shaderProgramTerrain.earthColorUniform = gl.getUniformLocation(shaderProgramTerrain, "uEarthColors");
            shaderProgramTerrain.rockColorUniform = gl.getUniformLocation(shaderProgramTerrain, "uRockColors");
            shaderProgramTerrain.sandColorUniform = gl.getUniformLocation(shaderProgramTerrain, "uSandColors");
            shaderProgramTerrain.earthNormalUniform = gl.getUniformLocation(shaderProgramTerrain, "uEarthNormals");
            shaderProgramTerrain.rockNormalUniform = gl.getUniformLocation(shaderProgramTerrain, "uRockNormals");
            shaderProgramTerrain.sandNormalUniform = gl.getUniformLocation(shaderProgramTerrain, "uSandNormals");

            //Light specs
            shaderProgramTerrain.lightingDirectionUniform = gl.getUniformLocation(shaderProgramTerrain, "uLightPosition");
            shaderProgramTerrain.ambientIntensityUniform = gl.getUniformLocation(shaderProgramTerrain, "uAmbientIntensity");
            shaderProgramTerrain.diffuseIntensityUniform = gl.getUniformLocation(shaderProgramTerrain, "uDiffuseIntensity");
            shaderProgramTerrain.specularIntensityUniform = gl.getUniformLocation(shaderProgramTerrain, "uSpecularIntensity");

            //Material specs
            shaderProgramTerrain.ambientReflectivityUniform = gl.getUniformLocation(shaderProgramTerrain, "uAmbientReflectivity");
            shaderProgramTerrain.diffuseReflectivityUniform = gl.getUniformLocation(shaderProgramTerrain, "uDiffuseReflectivity");
            shaderProgramTerrain.specularReflectivityUniform = gl.getUniformLocation(shaderProgramTerrain, "uSpecularReflectivity");
            shaderProgramTerrain.shininessUniform = gl.getUniformLocation(shaderProgramTerrain, "uShininess");
        }

        function initNormalReflectShader() {
            //Setup
            var fragmentShaderNormalReflectObj = getShader(gl, "shader-fs-normal-and-reflect");
            var vertexShaderNormalReflectObj = getShader(gl, "shader-vs-normal-and-reflect");
            shaderProgramNormalReflectObject = gl.createProgram();
            gl.attachShader(shaderProgramNormalReflectObject, vertexShaderNormalReflectObj);
            gl.attachShader(shaderProgramNormalReflectObject, fragmentShaderNormalReflectObj);
            gl.linkProgram(shaderProgramNormalReflectObject);
            if (!gl.getProgramParameter(shaderProgramNormalReflectObject, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            //Buffers & matrices
            shaderProgramNormalReflectObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramNormalReflectObject, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramNormalReflectObject.vertexPositionAttribute);
            shaderProgramNormalReflectObject.textureCoordAttribute = gl.getAttribLocation(shaderProgramNormalReflectObject, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramNormalReflectObject.textureCoordAttribute);
            shaderProgramNormalReflectObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramNormalReflectObject, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramNormalReflectObject.vertexNormalAttribute);
            shaderProgramNormalReflectObject.vertexTangentAttribute = gl.getAttribLocation(shaderProgramNormalReflectObject, "aVertexTangent");
            gl.enableVertexAttribArray(shaderProgramNormalReflectObject.vertexTangentAttribute);
            shaderProgramNormalReflectObject.vertexColorAttribute = gl.getAttribLocation(shaderProgramNormalReflectObject, "aVertexColor");
            gl.enableVertexAttribArray(shaderProgramNormalReflectObject.vertexColorAttribute);
            shaderProgramNormalReflectObject.pMatrixUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uPMatrix");
            shaderProgramNormalReflectObject.ViewMatrixUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uViewMatrix");
            shaderProgramNormalReflectObject.ModelMatrixUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uModelMatrix");
            shaderProgramNormalReflectObject.nMatrixUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uNMatrix");

            //Texture
            shaderProgramNormalReflectObject.normalMapUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "NormalMapTex");
            shaderProgramNormalReflectObject.cubeMapUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uCubeMap");

            //Camera
            shaderProgramNormalReflectObject.worldCameraPositionUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uWorldCameraPosition")

            //Light specs
            shaderProgramNormalReflectObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uLightPosition");
            shaderProgramNormalReflectObject.ambientIntensityUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uAmbientIntensity");
            shaderProgramNormalReflectObject.diffuseIntensityUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uDiffuseIntensity");
            shaderProgramNormalReflectObject.specularIntensityUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uSpecularIntensity");

            //Material specs
            shaderProgramNormalReflectObject.ambientReflectivityUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uAmbientReflectivity");
            shaderProgramNormalReflectObject.diffuseReflectivityUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uDiffuseReflectivity");
            shaderProgramNormalReflectObject.specularReflectivityUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uSpecularReflectivity");
            shaderProgramNormalReflectObject.shininessUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uShininess");
            shaderProgramNormalReflectObject.reflectFactorUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uReflectFactor");
            shaderProgramNormalReflectObject.alphaUniform = gl.getUniformLocation(shaderProgramNormalReflectObject, "uAlpha");
        }

        function initColoredShader(){
            var fragmentShaderColoredObj = getShader(gl, "shader-fs-colored-obj");
            var vertexShaderColoredObj = getShader(gl, "shader-vs-colored-obj");
            shaderProgramColoredObject = gl.createProgram();
            gl.attachShader(shaderProgramColoredObject, vertexShaderColoredObj);
            gl.attachShader(shaderProgramColoredObject, fragmentShaderColoredObj);
            gl.linkProgram(shaderProgramColoredObject);
            if (!gl.getProgramParameter(shaderProgramColoredObject, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
            shaderProgramColoredObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramColoredObject, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramColoredObject.vertexPositionAttribute);
            shaderProgramColoredObject.vertexColorAttribute = gl.getAttribLocation(shaderProgramColoredObject, "aVertexColor");
            gl.enableVertexAttribArray(shaderProgramColoredObject.vertexColorAttribute);
            shaderProgramColoredObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramColoredObject, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramColoredObject.vertexNormalAttribute);
            shaderProgramColoredObject.pMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uPMatrix");
            shaderProgramColoredObject.ViewMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uViewMatrix");
            shaderProgramColoredObject.ModelMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uModelMatrix");
            shaderProgramColoredObject.nMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uNMatrix");
            shaderProgramColoredObject.samplerUniform = gl.getUniformLocation(shaderProgramColoredObject, "uSampler");
            shaderProgramColoredObject.useLightingUniform = gl.getUniformLocation(shaderProgramColoredObject, "uUseLighting");
            shaderProgramColoredObject.ambientColorUniform = gl.getUniformLocation(shaderProgramColoredObject, "uAmbientColor");
            shaderProgramColoredObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramColoredObject, "uLightPosition");
            shaderProgramColoredObject.directionalColorUniform = gl.getUniformLocation(shaderProgramColoredObject, "uDirectionalColor");
        }

        var camera_matrix = mat4.create();
        var pMatrix = mat4.create();

        var mouseDown = false;
        var lastMouseX = null;
        var lastMouseY = null;

        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }

        var data = {
            river_curve : new BSpline([
                [150, 0, 0],
                [200, 0, 75],
                [150, 0, 150],
                [100, 0, 225],
                [150, 0, 300]
            ]),
            ph1 : 7.5, // Ground height
            ph2 : 6.5, // Max road height
            ph3 : 22, // Min height from road to top of tower
            s1 : 1.2,
            river_width : 120,
            n_towers : 2,
            bridge_pos : 0,
            bridge_width : 15,
            refresh: function(){
                scene = new Scene();
            }
        };

        var camera = new OrbitalCamera();
        var orbital = true;
        var scene = null;
        var ahead = 0, sideways = 0;

        function drawScene() {
            // Se configura el viewport
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Se configura la matriz de proyeccion
            mat4.perspective(pMatrix, 3.14/12.0, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0);

            // Definimos la ubicacion de la camara
            camera.update();
            if (ahead < -1) ahead = -1;
            if (ahead > 1) ahead = 1;
            if (sideways < -1) sideways = -1;
            if (sideways > 1) sideways = 1;

            // Dibujamos un objeto en el centro de la escena
            scene.draw();
        }

        function tick() {
            requestAnimFrame(tick);
            drawScene();
        }

        function webGLStart() {
            var canvas = document.getElementById("tp");
            initGL(canvas);
            initShaders();

            listen(canvas);

            scene = new Scene();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            tick();
        }

        function toggle_cam(){
            if (orbital) {
                camera = new FPCamera(data);
            } else {
                camera = new OrbitalCamera();
            }
            orbital = !orbital;
        }

        function listen(object){
            if (object.addEventListener) {
                // IE9, Chrome, Safari, Opera
                object.addEventListener("mousewheel", camera.onWheel, false);
                // Firefox
                object.addEventListener("DOMMouseScroll", camera.onWheel, false);
            }
            // IE 6/7/8
            else object.attachEvent("onmousewheel", camera.onWheel);
        }

        var panel;
    </script>

</head>

<body onload="webGLStart();">
        <canvas id="tp" style="border: none;" width="1150" height="650"
                onmousedown="onMouseClick()"
                onmouseup="onMouseRelease()"
                onmousemove="camera.onMovement(event)">
        </canvas>
        <canvas id="river_draw" width="180" height="180"
                onmousedown="panel.onMouseClick(event)">
        </canvas>
        <h1>Trabajo Pr&aacute;ctico 2016 - Marcos Vrljicak</h1>
        <p> X - Cambio de cámara <br />
            Cámara orbital: <br />
            - Rotar arrastrando el mouse <br />
            - Acercarse y/o alejarse con la rueda del mouse <br />
            Primera persona: <br />
            - Moverse con WASD <br />
            - Mirar alrededor moviendo el mouse <br />
            Abrir opciones para modificar los parametros del puente <br />
            Colocar puntos de control en el panel de la derecha para dibujar el río <br />
            En ambos casos debe presionarse "refresh" en la pesta�a de controles para que los cambios surtan efecto <br />
        </p>

    <script>
        GUI();
        panel = new RiverPanel(data);
        panel.draw();

        $("body")
            .keydown(function(e){
                if (e.keyCode == 88) toggle_cam(); // X
                    if (e.keyCode == 87) ahead += 1; // W
                    if (e.keyCode == 65) sideways -= 1; // A
                    if (e.keyCode == 83) ahead -= 1; // S
                    if (e.keyCode == 68) sideways += 1; // D

            })
            .keyup(function(e){
                    if (e.keyCode == 87) ahead = 0; // W
                    if (e.keyCode == 65) sideways = 0; // A
                    if (e.keyCode == 83) ahead = 0; // S
                    if (e.keyCode == 68) sideways = 0; // D

            });
    </script>

</body>

</html>
