<html>

<head>
    <title>Sistemas Gráficos - 66.71</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

    <link rel="stylesheet" href="styles.css">

    <script type="text/javascript" src="libs/gl-matrix.js"></script>
    <script type="text/javascript" src="libs/jquery-2.1.4.min.js"></script>
    <script type="text/javascript" src="libs/webgl-utils.js"></script>
    <script src="libs/dat.gui.min.js"></script>

    <script type="text/javascript" src="textured_sphere.js"></script>
    <script type="text/javascript" src="colored_geometry.js"></script>
    <script type="text/javascript" src="colored_sphere.js"></script>
    <script type="text/javascript" src="colored_cylinder.js"></script>
    <script type="text/javascript" src="h_section.js"></script>
    <script type="text/javascript" src="h_transition.js"></script>
    <script type="text/javascript" src="h_cap.js"></script>
    <script type="text/javascript" src="curve.js"></script>
    <script type="text/javascript" src="bezier_curve.js"></script>
    <script type="text/javascript" src="bspline_base.js"></script>
    <script type="text/javascript" src="bspline.js"></script>
    <script type="text/javascript" src="colored_string.js"></script>
    <script type="text/javascript" src="gui.js"></script>
    <script type="text/javascript" src="orbital_camera.js"></script>
    <script type="text/javascript" src="fp_camera.js"></script>
    <script type="text/javascript" src="guide.js"></script>
    <script type="text/javascript" src="tensor_set.js"></script>
    <script type="text/javascript" src="support.js"></script>
    <script type="text/javascript" src="river.js"></script>
    <script type="text/javascript" src="land.js"></script>
    <script type="text/javascript" src="crown.js"></script>
    <script type="text/javascript" src="pillar.js"></script>
    <script type="text/javascript" src="road.js"></script>
    <script type="text/javascript" src="tower.js"></script>
    <script type="text/javascript" src="bridge.js"></script>
    <script type="text/javascript" src="tree.js"></script>
    <script type="text/javascript" src="scene.js"></script>
    <script type="text/javascript" src="river_panel.js"></script>

    <script id="shader-fs-colored-obj" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vVertexColor;
        varying vec3 vLightWeighting;

        uniform sampler2D uSampler;

        void main(void) {
            gl_FragColor = vec4(vVertexColor.rgb * vLightWeighting, 1.0);
        }
    </script>

    <script id="shader-vs-colored-obj" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec3 aVertexColor;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        uniform vec3 uAmbientColor;

        uniform vec3 uLightPosition;
        uniform vec3 uDirectionalColor;

        uniform bool uUseLighting;

        varying vec3 vVertexColor;
        varying vec3 vLightWeighting;

        void main(void) {

            // Transformamos al vertice al espacio de la camara
            vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            // Transformamos al vertice al espacio de la proyeccion
            gl_Position = uPMatrix * pos_camera_view;

            // Coordenada de textura sin modifiaciones
            vVertexColor = aVertexColor;

            ////////////////////////////////////////////
            // Calculos de la iluminacion
            vec3 light_dir =  uLightPosition;
            normalize(light_dir);
            if (!uUseLighting)
            {
                vLightWeighting = vec3(1.0, 1.0, 1.0);
            }
            else
            {
                vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
                float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
                vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
            }
            ////////////////////////////////////////////
        }
    </script>

    <script id="shader-fs-textured-obj" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        uniform sampler2D uSampler;

        void main(void) {
            vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
            gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        }
    </script>

    <script id="shader-vs-textured-obj" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;

        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        uniform vec3 uAmbientColor;

        uniform vec3 uLightPosition;
        uniform vec3 uDirectionalColor;

        uniform bool uUseLighting;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        void main(void) {

            // Transformamos al vertice al espacio de la camara
            vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

            // Transformamos al vertice al espacio de la proyeccion
            gl_Position = uPMatrix * pos_camera_view;

            // Coordenada de textura sin modifiaciones
            vTextureCoord = aTextureCoord;

            ////////////////////////////////////////////
            // Calculos de la iluminacion
            vec3 light_dir =  uLightPosition;
            normalize(light_dir);
            if (!uUseLighting)
            {
                vLightWeighting = vec3(1.0, 1.0, 1.0);
            }
            else
            {
                vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
                float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
                vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
            }
            ////////////////////////////////////////////
        }
    </script>

    <script type="text/javascript">
        function onMouseClick(){
            mouseDown = true;
        }
        function onMouseRelease(){
            mouseDown = false;
            lastMouseX = null;
            lastMouseY = null;
        }
    </script>

    <script type="text/javascript">
        var gl;

        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {}
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function getShader(gl, id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }

            var str = "";
            var k = shaderScript.firstChild;
            while (k) {
                if (k.nodeType == 3) {
                    str += k.textContent;
                }
                k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, str);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        var shaderProgramTexturedObject;
        var shaderProgramColoredObject;

        function initShaders() {
            // Inicializamos lo relacionado con el program shader para
            // renderizar objetos texturados

            var fragmentShaderTexturedObj = getShader(gl, "shader-fs-textured-obj");
            var vertexShaderTexturedObj = getShader(gl, "shader-vs-textured-obj");

            shaderProgramTexturedObject = gl.createProgram();
            gl.attachShader(shaderProgramTexturedObject, vertexShaderTexturedObj);
            gl.attachShader(shaderProgramTexturedObject, fragmentShaderTexturedObj);
            gl.linkProgram(shaderProgramTexturedObject);

            if (!gl.getProgramParameter(shaderProgramTexturedObject, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            shaderProgramTexturedObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramTexturedObject.vertexPositionAttribute);

            shaderProgramTexturedObject.textureCoordAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramTexturedObject.textureCoordAttribute);

            shaderProgramTexturedObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramTexturedObject.vertexNormalAttribute);

            shaderProgramTexturedObject.pMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uPMatrix");
            shaderProgramTexturedObject.ViewMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uViewMatrix");
            shaderProgramTexturedObject.ModelMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uModelMatrix");
            shaderProgramTexturedObject.nMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uNMatrix");
            shaderProgramTexturedObject.samplerUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uSampler");
            shaderProgramTexturedObject.useLightingUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uUseLighting");
            shaderProgramTexturedObject.ambientColorUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uAmbientColor");
            shaderProgramTexturedObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uLightPosition");
            shaderProgramTexturedObject.directionalColorUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uDirectionalColor");

            // Inicializamos lo relacionado con el program shader para
            // renderizar objetos Coloreados

            var fragmentShaderColoredObj = getShader(gl, "shader-fs-colored-obj");
            var vertexShaderColoredObj = getShader(gl, "shader-vs-colored-obj");

            shaderProgramColoredObject = gl.createProgram();
            gl.attachShader(shaderProgramColoredObject, vertexShaderColoredObj);
            gl.attachShader(shaderProgramColoredObject, fragmentShaderColoredObj);
            gl.linkProgram(shaderProgramColoredObject);

            if (!gl.getProgramParameter(shaderProgramColoredObject, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            shaderProgramColoredObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramColoredObject, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramColoredObject.vertexPositionAttribute);

            shaderProgramColoredObject.vertexColorAttribute = gl.getAttribLocation(shaderProgramColoredObject, "aVertexColor");
            gl.enableVertexAttribArray(shaderProgramColoredObject.vertexColorAttribute);

            shaderProgramColoredObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramColoredObject, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramColoredObject.vertexNormalAttribute);

            shaderProgramColoredObject.pMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uPMatrix");
            shaderProgramColoredObject.ViewMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uViewMatrix");
            shaderProgramColoredObject.ModelMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uModelMatrix");
            shaderProgramColoredObject.nMatrixUniform = gl.getUniformLocation(shaderProgramColoredObject, "uNMatrix");
            shaderProgramColoredObject.samplerUniform = gl.getUniformLocation(shaderProgramColoredObject, "uSampler");
            shaderProgramColoredObject.useLightingUniform = gl.getUniformLocation(shaderProgramColoredObject, "uUseLighting");
            shaderProgramColoredObject.ambientColorUniform = gl.getUniformLocation(shaderProgramColoredObject, "uAmbientColor");
            shaderProgramColoredObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramColoredObject, "uLightPosition");
            shaderProgramColoredObject.directionalColorUniform = gl.getUniformLocation(shaderProgramColoredObject, "uDirectionalColor");
        }

        var camera_matrix = mat4.create();
        var mvMatrix = mat4.create();
        var mvMatrixStack = [];
        var pMatrix = mat4.create();

        var mouseDown = false;
        var lastMouseX = null;
        var lastMouseY = null;

        //////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////

        function mvPushMatrix() {
            var copy = mat4.create();
            mat4.set(mvMatrix, copy);
            mvMatrixStack.push(copy);
        }

        function mvPopMatrix() {
            if (mvMatrixStack.length == 0) {
                throw "Invalid popMatrix!";
            }
            mvMatrix = mvMatrixStack.pop();
        }

        function setViewProjectionMatrix() {
            gl.uniformMatrix4fv(shaderProgramTexturedObject.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(shaderProgramTexturedObject.ViewMatrixUniform, false, camera_matrix);
        }

        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }

        //////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////

        var data = {
            river_curve : new BSpline([
                [150, 0, 0],
                [200, 0, 75],
                [150, 0, 150],
                [100, 0, 225],
                [150, 0, 300]
            ]),
            ph1 : 7.5, // Ground height
            ph2 : 6.5, // Max road height
            ph3 : 16, // Min height from road to top of tower
            s1 : 1.5,
            river_width : 120,
            n_towers : 2,
            bridge_pos : 0,
            bridge_width : 15,
            refresh: function(){
                scene = new Scene();
            }
        };

        var camera = new OrbitalCamera();
        var orbital = true;
        var scene = null;
        var ahead = 0, sideways = 0;

        function drawScene() {
            // Se configura el viewport
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Se configura la matriz de proyeccion
            mat4.perspective(pMatrix, 3.14/12.0, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0);

            // Definimos la ubicacion de la camara
            camera.update();
            if (ahead < -1) ahead = -1;
            if (ahead > 1) ahead = 1;
            if (sideways < -1) sideways = -1;
            if (sideways > 1) sideways = 1;

            // Dibujamos un objeto en el centro de la escena
            scene.draw();
        }

        function tick() {
            requestAnimFrame(tick);
            drawScene();
        }

        function webGLStart() {
            var canvas = document.getElementById("tp");
            initGL(canvas);
            initShaders();

            listen(canvas);

            scene = new Scene();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            tick();
        }

        function toggle_cam(){
            if (orbital) {
                camera = new FPCamera(data);
            } else {
                camera = new OrbitalCamera();
            }
            orbital = !orbital;
        }

        function listen(object){
            if (object.addEventListener) {
                // IE9, Chrome, Safari, Opera
                object.addEventListener("mousewheel", camera.onWheel, false);
                // Firefox
                object.addEventListener("DOMMouseScroll", camera.onWheel, false);
            }
            // IE 6/7/8
            else object.attachEvent("onmousewheel", camera.onWheel);
        }

        var panel;
    </script>

</head>

<body onload="webGLStart();">
        <canvas id="tp" style="border: none;" width="1150" height="650"
                onmousedown="onMouseClick()"
                onmouseup="onMouseRelease()"
                onmousemove="camera.onMovement(event)">
        </canvas>
        <canvas id="river_draw" width="180" height="180"
                onmousedown="panel.onMouseClick(event)">
        </canvas>
        <h1>Trabajo Pr&aacute;ctico 2016 - Marcos Vrljicak</h1>
        <p> X - Cambio de cámara <br />
            Cámara orbital: <br />
            - Rotar arrastrando el mouse <br />
            - Acercarse y/o alejarse con la rueda del mouse <br />
            Primera persona: <br />
            - Moverse con WASD <br />
            - Mirar alrededor moviendo el mouse <br />
            Abrir opciones para modificar los parametros del puente <br />
            Colocar puntos de control en el panel de la derecha para dibujar el río <br />
            En ambos casos debe presionarse "refresh" en la pestaña de controles para que los cambios surtan efecto <br />
        </p>

    <script>
        GUI();
        panel = new RiverPanel(data);
        panel.draw();

        $("body")
            .keydown(function(e){
                if (e.keyCode == 88) toggle_cam(); // X
                if (!orbital) {
                    if (e.keyCode == 87) ahead += 1; // W
                    if (e.keyCode == 65) sideways -= 1; // A
                    if (e.keyCode == 83) ahead -= 1; // S
                    if (e.keyCode == 68) sideways += 1; // D
                }
            })
            .keyup(function(e){
                if (!orbital) {
                    if (e.keyCode == 87) ahead = 0; // W
                    if (e.keyCode == 65) sideways = 0; // A
                    if (e.keyCode == 83) ahead = 0; // S
                    if (e.keyCode == 68) sideways = 0; // D
                }
            });
    </script>

</body>

</html>
